<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<script src="http://d3js.org/d3.v4.js"></script>
<script src="../../bower_components/moment/min/moment.min.js"></script>

<dom-module id="state-quick-chart">

  <template>
    <style include="paper-material">
        .chart-container {
          padding: 20px;
          position: relative;
        }

        .line {
          fill: none;
          stroke: steelblue;
          stroke-width: 2px;
        }
    </style>
    <div id="chart" class="chart-container">
      <div id="outerlegend">
         <div class="innerlegend"></div>
      </div>
      <div id="chartWrapper">
          <svg id="svg"></svg>
      </div>
    </div>

  </template>

</dom-module>

<script>
(function () {
  'use strict';

  Polymer({
    is: 'state-quick-chart',

    properties: {
      hass: {
        type: Object,
      },
      chartType: {
        type: String,
        value: ""
      },
      chartLabel: {
        type: String,
        value: ""
      },
      chartId: {
        type: String,
        value: ""
      },
      componentName: {
        type: String,
        value: ""
      },
      updateMethod: {
        type: String,
        value: ""
      },
      unit: {
        type: String,
      },

      isAttached: {
        type: Boolean,
        value: false
      },

      chartEngine: {
        type: Object,
      },

      _apiLoaded: {
        type: Boolean,
        value: false,
      },
      url: {
        type: String,
        value: 'data.csv'
      },
      chartData: {
        type: Object,
        value: {},
        observer: 'dataChanged'
      },
      cardWidth: {
        type: Number,
        value: 400
      },
      aggregation: {
        type: Boolean,
        value: false
      }
    },
    ready: function() {
      // this.setUpChart();
    },
    setDimensions: function () {
      if (this.chartType)
      {
        this.margin = {top: 20, right: 80, bottom: 30, left: 20};
        this.chartWidth = this.cardWidth - this.margin.left - this.margin.right;
        this.chartHeight = this.cardWidth - this.margin.top - this.margin.bottom;
      }
    },
    dataChanged: function (chartData) {

      if (chartData)
      { 
        switch (this.chartType)
        {
          case 'line':
          {
            const series = Object.keys(chartData.series);
            this.updateLineChart(this.extractData(chartData), series, chartData.series);
            break;
          }
          case 'bar':
          {
            const series = Object.keys(chartData.series);
            this.updateBarChart(this.extractBarData(chartData), series, chartData.series);
            break;
          }
        }
      }
    },
    setUpLineChart: function (data, series, chartInfo) {

      this.setDimensions();

      this.svgg = d3.select(this.$.svg)
          .attr("width", this.chartWidth + this.margin.left + this.margin.right)
          .attr("height", this.chartHeight + this.margin.top + this.margin.bottom)
        .append("g")
          .attr("class", "svg-g")
          .attr("id", "svgg")
          .style("z-index", "8")
          .attr("transform",
                "translate(40," + this.margin.top + ")");

        // set the ranges
        this.lineX = d3.scaleTime().range([0, this.chartWidth]);
        this.lineY = d3.scaleLinear().range([this.chartHeight, 0]);

        // Scale the range of the data
        this.lineX.domain(d3.extent(data, function(d) { 
          return d.date; 
        }));
        
        this.lineY.domain([0, d3.max(data, function(d) {

          const vals = [];

          series.forEach((key) => {
            if (d[key])
            {
              vals.push(d[key]);
            }
          });

          const max = vals.reduce(function(a, b) {
              return Math.max(a, b);
          });

          return max; 
        })]);

        // Add the X Axis
        this.svgg.append("g")
            .attr("class", "x-axis")
            .attr("transform", "translate(0," + this.chartHeight + ")")
            .call(d3.axisBottom(this.lineX)
              .tickFormat(d3.timeFormat("%m/%d")));

        // Add the Y Axis
        this.svgg.append("g")
            .attr("class", "y-axis")
            .call(d3.axisLeft(this.lineY));

        this.vertical = d3.select(this.$.chartWrapper).append("div")
          .attr("class", "remove")
          .style("position", "absolute")
          .style("z-index", 9)
          .style("width", "1px")
          .style("height", this.chartHeight + "px")
          .style("top", "50px")
          .style("bottom", "10px")
          .style("left", "0px")
          .style("background", "gray")
          .style("opacity", 0)
          .style("transform",
            "translateY(20px)");

        this.tool_tip = d3.select("body").append("div")
          .attr("class", "tooltip")
          .style("opacity", 0)
          .style("position", "absolute")
          .style("text-align", "left")
          .style("padding", "2px")
          .style("font", "12px sans-serif")
          .style("background", "#ffd54f")
          .style("border", "0px")
          .style("border-radius", "2px")
          .style("pointer-events", "none")
          .style("color", "black")
          .style("padding", "10px")
          .style("width", "120px")
          .style("height", "120px")
          .style("box-shadow", "2px 2px 2px 1px rgba(0, 0, 0, .2)");

        this.addLegend(series, chartInfo, 'line');
    },
    updateLineChart: function (data, series, chartInfo) {

      if (typeof this.lineX !== 'function')
      {
        this.setUpLineChart(data, series, chartInfo);
      }      

      var svg = d3.select(this.$.svg).select('.svg-g');

      const that = this;

      // Scale the range of the data
      this.lineX.domain(d3.extent(data, function(d) { 
        return d.date; 
      }));
      
      this.lineY.domain([0, d3.max(data, function(d) {

        const vals = [];

        series.forEach((key) => {
          if (d[key])
          {
            vals.push(d[key]);
          }
        });

        const max = vals.reduce(function(a, b) {
            return Math.max(a, b);
        });

        return max; 
      })]);
      
      // Add the X Axis
      svg.selectAll(".x-axis")
          .call(d3.axisBottom(this.lineX)
            .tickFormat(d3.timeFormat("%m/%d")));

      // Add the Y Axis
      svg.selectAll(".y-axis")
          .call(d3.axisLeft(this.lineY));

      series.reverse().forEach((key, index) => { 

        var formatTime = d3.timeFormat("%e %B");

        const drawLine = d3.line()
          .x(function(d) { 
            // console.log('date: ' + d.date);
            return that.lineX(d.date); 
          })
          .y(function(d) { 
            // console.log(key + ': ' + d[key]);
            return that.lineY(d[key]); 
          })
          .defined(function(d) { return d[key]; });

        let color = this.colorMap(index);

        if (chartInfo)
        {
          if (chartInfo[series[index]] && chartInfo[series[index]].color)
          {
            color = chartInfo[series[index]].color;
          }
        }

        const lineStyle = chartInfo[series[index]]['line-style'];

        const selection = svg.selectAll(`.line.${key}`)
          .data([data])
          .attr("d", drawLine);

        const ent = selection.enter()
          .append("path")
          .attr("class", `line ${key}`)
          .style("stroke", color)
          .attr("d", drawLine);

        if (lineStyle && lineStyle === 'dash')
        {
          ent.style("stroke-dasharray", "6,4");
        }
        else if (lineStyle && lineStyle === 'dot')
        {
          ent.style("stroke-dasharray", "2,2");
        }
      });

      const mouseOffset = 10;

      this.svgg
        .append("rect")
        .attr("class", "overlay")
        .attr("width", this.chartWidth)
        .attr("height", this.chartHeight)
        .attr("opacity", 0)
        .on("mousemove", function() { 

          // vertical line
          const leftEdge = that.getClientRects()[0].left;
          let leftPos = d3.event.pageX - leftEdge + 5;

          that.vertical.style("left", (leftPos) + "px");

          // tooltip
          const mousex = d3.mouse(this);
          const invertedx = that.lineX.invert(mousex[0] + mouseOffset);

          const xDate = moment(invertedx).format('MM/DD');

          const dateInfo = that.getDateInfo(data, xDate);

          if (dateInfo !== null)
          {
            that.tool_tip.transition()
              .duration(0)
              .style("opacity", .9);

            const rightEdge = that.getClientRects()[0].right;

            const tooltipWidth = that.tool_tip.node().getClientRects()[0].width;

            leftPos = d3.event.pageX;

            if (leftPos > rightEdge - tooltipWidth)
            {
                leftPos = rightEdge - tooltipWidth;
            }

            that.tool_tip.html(that.getTooltipMessage(xDate, dateInfo))
              .style("left", leftPos + "px")
              .style("top", (d3.event.pageY - 28) + "px");
          }
          else
          {
            that.tool_tip.transition()
              .duration(1000)
              .style("opacity", 0);
          }
        })
        .on("mouseover", function() {  
          // const mousex = d3.mouse(this);
          const leftEdge = that.getClientRects()[0].left;
          const leftPos = d3.event.pageX - leftEdge;

          that.vertical.style("left", (leftPos) + "px");
          that.vertical.style("opacity", 1);
        })
        .on("mouseout", function () {

          // vertical line
          that.vertical.style("opacity", 0);

          // tooltip
          that.tool_tip.transition()
            .duration(1000)
            .style("opacity", 0);
        });

      // if (this.chartData)
      // {
      //   this.chartData = this.updateData(this.chartData, 'days');
      // }
      
      // this.dataGenerator(this.chartData);
    },
    getDateInfo: function (data, xDate) {
        const d = data.find((datum) => (
            moment(datum.date).format('MM/DD') === xDate
        ));
        
        return (typeof d !== 'undefined' ? d : null);
    },
    getTooltipMessage: function (xDate, d) {
        let messageInfo = '';

        if (typeof d !== 'undefined')
        {
            messageInfo = "<br/>historical: " + d.display.historical + "<br/>transactive: " + d.display.transactive;

            if (d.actual !== null)
            {
                messageInfo = messageInfo + "<br/>actual: " + d.display.actual;
            }
        }

        return ("Outlook of " + xDate + "<br/>Energy use: 50 kWh<br/>Energy cost: $5<br/>Energy savings: $2" + "<br/>" + messageInfo);
    },
    updateData: function (chartSeries, timeperiod) {

      const newTime = moment(chartSeries.times[9]).add(1, timeperiod).toDate();

      console.log(newTime);

      const newSeries = chartSeries;

      newSeries.times.shift();
      newSeries.times.push(newTime);

      Object.keys(newSeries.series).forEach((key, index) => {
        const newValue = newSeries.series[key].points[9] + index;
        newSeries.series[key].points.shift();
        newSeries.series[key].points.push(newValue);
      });

      return newSeries;
    },
    dataGenerator: function(chartData) {

      const that = this;

      setTimeout(function() {
          console.log("timer");
           
          that.dataChanged(chartData);

          // do forever
          // that.dataGenerator();
        }, 2000);

    },
    setUpBarChart: function (data, series, chartInfo) {

      this.setDimensions();

      var svg = d3.select(this.$.svg)
          .attr("width", this.chartWidth + this.margin.left + this.margin.right)
          .attr("height", this.chartHeight + this.margin.top + this.margin.bottom)
        .append("g")
          .attr("class", "svg-g")
          .attr("transform",
                "translate(0," + this.margin.top + ")");

      this.barX = d3.scaleBand()
          .rangeRound([0, this.chartWidth]);

      this.barY = d3.scaleLinear()
          .rangeRound([this.chartHeight, 0]);

      this.barZ = d3.scaleOrdinal(d3.schemeCategory20);

      var stack = d3.stack()
          .keys(series)
          .order(d3.stackOrderNone)
          .offset(d3.stackOffsetNone);

      var layers = stack(data);

      this.barX.domain(layers[0].map(function(d) { 
        return d.data.date; 
      }));

      this.barY.domain([0, d3.max(layers[layers.length - 1], function(d) { 
        return d3.max([d[0], d[1]]); 
      })]).nice();

      var xAxis = d3.axisBottom(this.barX).tickFormat(d3.timeFormat("%H:%M"));

      // var yAxis = d3.axisRight(y);
      var yAxis = d3.axisRight(this.barY)
          .scale(this.barY);
          
      svg.append("g")
          .attr("class", "axis x-axis")
          .attr("transform", "translate(0," + this.chartHeight + ")")
          .call(xAxis);

      svg.append("g")
          .attr("class", "axis y-axis")
          .attr("transform", "translate(" + this.chartWidth + ",0)")
          .call(yAxis);

      this.addLegend(series, chartInfo, 'bar');
    },
    updateBarChart: function (data, series, chartInfo) {

      if (typeof this.barX !== 'function')
      {
        this.setUpBarChart(data, series, chartInfo);
      }  

      var svg = d3.select(this.$.svg).select('.svg-g');

      var stack = d3.stack()
          .keys(series)
          .order(d3.stackOrderNone)
          .offset(d3.stackOffsetNone);

      var layers = stack(data);

      this.barX.domain(layers[0].map(function(d) { 
        return d.data.date; 
      }));

      this.barY.domain([0, d3.max(layers[layers.length - 1], function(d) { 
        return d3.max([d[0], d[1]]); 
      })]).nice();

      var xAxis = d3.axisBottom(this.barX).tickFormat(d3.timeFormat("%H:%M"));

      // var yAxis = d3.axisRight(y);
      var yAxis = d3.axisRight(this.barY)
          .scale(this.barY);

      // Add the X Axis
      svg.selectAll(".x-axis")
          .call(xAxis);

      // Add the Y Axis
      svg.selectAll(".y-axis")
          .call(yAxis);

      const that = this;

      svg.selectAll(".layer").remove();

      var layer = svg.selectAll(".layer")
          .data(layers)
          .enter().append("g")
          .attr("class", "layer")
          .style("fill", function(d, i) {
            return that.barZ(i); 
          });

      const rects = layer.selectAll("rect")
          .data(function(d) { 
            return d; 
          })
          .enter().append("rect")
          .attr("x", function(d) { 
            return that.barX(d.data.date); 
          })
          .attr("y", function(d) { 
            return that.barY(d[1]); 
          })
          .attr("height", function(d) { 
            return that.barY(d[0]) - that.barY(d[1]); 
          })
          .attr("width", this.barX.bandwidth() - 1);
      
      // if (this.chartData)
      // {
      //   this.chartData = this.updateData(this.chartData, 'minutes');
      // }
      
      // this.dataGenerator(this.chartData);
    },
    addLegend: function (series, chartInfo, chartType) {
      var lwidth = 500;
      var lheight = 75;
      var svgh = 20;

      var svgLegend = d3.select(this.$.outerlegend)
          .append("svg")
          .attr("width", lwidth)
          .attr("height", lheight - 50)
          .attr("transform", "translate(50,20)");
      
      var dataL = 0;
      var offset = 80;
      
      var legend = svgLegend.selectAll('.innerlegend')
          .data(series)
          .enter().append('g')
          .attr("class", "legend")
          .attr("transform", function (d, i) {
           if (i === 0) {
              dataL = d.length + offset; 
              return "translate(0,0)";
          } else { 
           var newdataL = dataL;
           dataL +=  d.length + offset;
           return "translate(" + (newdataL) + ",0)";
          }
      });
      
      var z = d3.scaleOrdinal(d3.schemeCategory20);

      let swatchHeight = 2;
      let swatchWidth = 16;
      let swatchY = 4;

      if (chartType === 'bar')
      {
          swatchHeight = 10;
          swatchWidth = 10;
          swatchY = 0;

          legend.append('rect')
              .attr("x", 0)
              .attr("y", swatchY)
              .attr("width", 10)
              .attr("height", swatchHeight)
              .style("fill", function (d, i) {

                const color = (
                  chartInfo[series[i]].color ? 
                  chartInfo[series[i]].color : 
                  z(i)
                );
              return color;
          });
      }
      else 
      {
          legend.append('defs')
            .append('pattern')
              .attr('id', 'dash-pattern')
              .attr('patternUnits', 'userSpaceOnUse')
              .attr('width', 8)
              .attr('height', 4)
            .append('path')
              .attr('d', 'M0,-2 l0,10 M8,-2 l0,10')
              .attr('stroke', '#ffffff')
              .attr('stroke-width', 4);

            legend.append('pattern')
              .attr('id', 'dot-pattern')
              .attr('patternUnits', 'userSpaceOnUse')
              .attr('width', 4)
              .attr('height', 4)
            .append('path')
              .attr('d', 'M0,0l0,6')
              .attr('stroke', '#ffffff')
              .attr('stroke-width', 4);

            legend.append('rect')
                .attr("x", 0)
                .attr("y", swatchY)
                .attr("width", swatchWidth)
                .attr("height", swatchHeight)
                .style("fill", function (d, i) {

                  const color = (
                    chartInfo[series[i]].color ? 
                    chartInfo[series[i]].color : 
                    z(i)
                  );
                return color;
            });

            legend.append("rect")
                .attr("x", 0)
                .attr("y", swatchY)
                .attr("width", swatchWidth)
                .attr("height", swatchHeight)
                .style("fill", function (d, i) {

                  let color = (
                    chartInfo[series[i]].color ? 
                    chartInfo[series[i]].color : 
                    z(i)
                  );

                  if (chartInfo[series[i]]['line-style'] === 'dash')
                  {
                    color = 'url(#dash-pattern)';
                  }
                  else if (chartInfo[series[i]]['line-style'] === 'dot')
                  {
                    color = 'url(#dot-pattern)';
                  }

                return color;
            });
      }

      // legend.append('rect')
      //     .attr("x", 0)
      //     .attr("y", swatchY)
      //     .attr("width", 10)
      //     .attr("height", swatchHeight)
      //     .style("fill", function (d, i) {

      //       const color = (
      //         chartInfo[series[i]].color ? 
      //         chartInfo[series[i]].color : 
      //         z(i)
      //       );
      //     return color;
      // });

      // legend.append("defs")
      //   .append("pattern")
      //     .attr("id", "hash4_4")
      //     .attr("width", 8)
      //     .attr("height", 8)
      //     .attr("patternUnits", "userSpaceOnUse")
      //     .attr("patternTransform", "rotate(60)")
      //   .append('rect')
      //     .attr("x", 0)
      //     .attr("y", swatchY)
      //     .attr("width", 10)
      //     .attr("height", swatchHeight)
      //     .style("fill", function (d, i) {

      //       const color = (
      //         chartInfo[series[i]].color ? 
      //         chartInfo[series[i]].color : 
      //         z(i)
      //       );
      //     return color;
      // });

      
      
      legend.append('text')
          .attr("x", swatchWidth + 2)
          .attr("y", 10)
      //.attr("dy", ".35em")
      .text(function (d, i) {
          return d;
      })
          .attr("class", "textselected")
          .style("text-anchor", "start")
          .style("font-size", 15);
    },
    refreshChart: function () {
      var me = this;

      me.g.data(me.pie(me.data))
        .select("path").attr("d", me.arc);

      me.g.select("text")
        .attr("transform", function(d) { 
          console.log("d: " + d);
          console.log("translate(" + me.arc.centroid(d) + ")");
          return "translate(" + me.arc.centroid(d) + ")"; 
        });
    },
    extractData: function (chartData) {
      const totals = {};

      if (this.aggregation)
      {
          Object.keys(chartData.series).forEach((key) => {
              totals[key] = 0;
          });
      }

      const data = chartData.times.map((t, index) => {
          const item = {
            date: moment(t).toDate(),
            display: {}
          };

          Object.keys(chartData.series).forEach((key) => {
            item[key] = null;

            if (chartData.series[key].hasOwnProperty('points'))
            { 
              if (chartData.series[key]['points'][index])
              {
                item[key] = chartData.series[key]['points'][index];

                item.display[key] = item[key];

                if (this.aggregation)
                {
                  totals[key] = totals[key] + item[key];

                  item[key] = totals[key];
                }
              }
            }
          });

          return item;
      });

      return data;
    },

    extractBarData: function (chartData) {
      const totals = {};

      if (this.aggregation)
      {
          Object.keys(chartData.series).forEach((key) => {
              totals[key] = 0;
          });
      }

      const data = chartData.times.map((t, index) => {
          const item = {
            date: moment(t).toDate(),
            display: {}
          };

          Object.keys(chartData.series).forEach((key) => {
            item[key] = null;

            if (chartData.series[key].hasOwnProperty('points'))
            { 
              if (chartData.series[key]['points'][index])
              {
                item[key] = chartData.series[key]['points'][index];

                item.display[key] = item[key];

                if (this.aggregation)
                {
                  totals[key] = totals[key] + item[key];

                  item[key] = totals[key];
                }
              }
            }
          });

          return item;
      });

      if (data.length < 10)
      {
        let lastTime = data[data.length - 1].date;

        let i;

        for (i = 0; i < 10 - data.length; i++)
        {
          const lastMoment = moment(lastTime);
        
          lastTime = lastMoment.add(chartData.step, 's').toDate();
          const blankItem = {
            date: lastTime,
            display: {}
          };

          Object.keys(chartData.series).forEach((key) => {
            blankItem[key] = null;
          });

          data.push(blankItem);
        }
      }

      return data;
    },

    created: function () {
      this.style.display = 'block';
    },

    attached: function () {
      this.isAttached = true;
    },
  changeChartType: function (ev) {
    const value = ev.currentTarget.value;

    if (value && this.updateMethod)
    {
      const updateObj = [{ 
        'id': this.chartId,
        'target': 'type',
        'value': value 
      }];
      
      this.callServiceHelper(this.updateMethod, updateObj);
    }
  },
  colorMap: function (index) {
    
    const colors = [
      '#29A6FF', // Celestine +1
      '#E87511', // Carnelian

      '#46A661', // Olivine
      '#00AFAA', // Malachite
      '#EA82FF', // Fluorite +1

      '#FF6B70', // Cinnabar +1

      '#00BDDD', // Zircon +1
      '#AFA1FF', // Amethyst +1
      '#F5EC5A', // Topaz

      '#8CCD5A', // Peridot
      '#FFBA59', // Citrine
      '#BF2A75', // Tourmaline
    ];

    const safeIndex = (colors.length - 1) % (index + 1);

    return colors[safeIndex];
  },
  callServiceHelper: function (service, data) {
    if (this.hass && this.componentName)
    {      
      this.hass.callService(this.componentName, service, { value: data})
        .then(function () {
        }.bind(this));
    }
  },

  });
}());
</script>